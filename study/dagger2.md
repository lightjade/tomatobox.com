# Dagger2

## 소스
http://square.github.io/dagger/

## Dagger2를 사용의 이점.
- Simplifies access to shared instances.
- Easy configuration of complex dependencies.
- Easier unit and integration testing.
- Scoped instances

## Annotation
- @Module + @Provides
	- mechanism for providing dependencies.
	- Module로 구성되고, 내부에서 객체들을 provide 해주는 것
	- @Provides
		- 객체 주입에 필요한 내용을 리턴해 주는것
	- @PerActivity
		- @Scope
		- @Retention(RUNTIME)
	- @PerApp
- @Component
	- beidge between modules and injections.
		- Module과 Inject간의 bridge 같은 역할
- @Inject
	- mechanism for requesting dependencies.
	- 객체의 주입
- 

## Prividing Dependencies
- Module은 dependency들을 제공하는 메소드를 포함한 클래스이다.
- @Module은 클래스에 작성한다.
- @Provides는 각 메소드들에 작성한다.
- 제공되는 dependency가 singleton이면 @Singleton을 추가한다.

## Requesting Dependencies
- @Inject 어노테이션이 필요하다.
- Constructor, field, method injectiion을 할 수 있다.
	- Constructor Injection
	- Method Injection
	- Field Injection

## Component
- beidge between modules and injections.
- The injector.
- It is Interface. Implementaiton is generated by Dagger2.
- Implementation of scopes.

## Scope Annotations
- Only create a single instance.
- @Singleton is the "largest" scope.

## 3 important question
1. Which object do you want to inject?
	- use @Provides
2. Where do you want to inject this object?
	- Use @Inject, @Component
3. How will you construct this object?
	- Create a class @Module
	- This class contains methods with @Provides.

## Any Annoations
- @Retention
     - Retention은 어노테이션이 얼마나 오랫동안 유지되는지에 대해, JVM이 어떻게 사용자 어노테이션을 다루어야 하는지를 서술합니다.
     	* SOURCE : 어노테이션이 컴파일 타임시 버려진다는 것을 의미합니다. 
     		* retention정책이 source로 정의되어 있으면, 클래스 파일은 어노테이션을 지니지 못합니다.
     	* CLASS : 어노테이션이 생성된 클래스 파일에서 나타날 것이라는 것을 의미합니다. 
     		* 런타임시에는 이 어노테이션을 이용하지 못합니다.
     	* RUNTIME : 런타임시 JVM에서 어노테이션의 이용이 가능하다는 것을 의미합니다. 
     		* 이러한 어노테이션을 읽는 사용자 로직을 가짐으로써 런타임시 무언가를 할 수 있습니다.
- @Qualifier
	- @Autowired를 보강해주는 어노테이션
	- @Autowired의 경우 byType으로 빈을 묶어주기 때문에 같은 타입이 2개 이상인 경우에 모호함 오류에 빠질 수 있다.
	- byType으로 빈을 묶더라도 보다 명확하게 묶일 수 있도록 @Qualifier를 사용한다.
	- 동일한 타입의 빈 객체들 중에서 특정 빈을 사용하도록 설정할수 있다.
- @Named
	- Dagger 안에 미리 정의된 qualifier 어노테이션
	- 같은 반환 타입의 두개의 서로 다른 객체가 필요할 때 사용된다.
	- 모듈안에서 `@Provides @Named("cached")` 로 표현하고,
		```
        @Provides @Named("cached")
        @Singleton
        OkHttpClient provideOkHttpClient(Cache cache) {
            OkHttpClient client = new OkHttpClient();
            client.setCache(cache);
            return client;
        }

        @Provides @Named("non_cached") @Singleton
        OkHttpClient provideOkHttpClient() {
            OkHttpClient client = new OkHttpClient();
            return client;
        }
        ```
	- 주입 받을 객체 안에서 `@Inject @Named("cached")` 로 사용한다.
		```
        @Inject @Named("cached") OkHttpClient client;
		@Inject @Named("non_cached") OkHttpClient client2;
        ```
	- Custom qualifier annotation.
		```
        @Qualifier
        @Documented
        @Retention(RUNTIME)
        public @interface DefaultPreferences {
        }
        ```
- @Scope
	- 주어진 Component안의 제공받은 객체의 싱글 인스턴스를 유지하기 위해 사용된다.
	- @Scope가 정의되지 않은 Provider 메소드는 Inject 될때마다 새로운 객체를 만들기위해 호출된다.
	```
    @Scope
    @Documented
    @Retention(value=RUNTIME)
    public @interface MyActivityScope
    ```
## 궁금한것
- @PerActivity와 @PerApp은 왜 만드는가?
	- Scope 정의
- 클래스에 @PerActivity를 붙이면 어떻게 되는가?
- @Scope는 무엇인가?
- @Retention은 무엇인가?

## Dagger 개발 순서
1. gradle에 dagger 의존성 추가.
2. 클래스 생성
	- 생성자에는 주입받을 객체를 매개변수로 받아야함.
3. Module 클래스 생성
	- 주입받을 객체의 모듈들을 @Module로 묶어준다.
	- 모듈 클래스 안에 제공해줄 객체 생성 메소드를 추가한다. (@Provide)
4. Component Interface 생성
	- Module과 inject 간의 다리 역할.
	- 생성한 Component를 컴파일하면 Dagger[Component Name] 클래스가 만들어진다.
	- DaggerXXXXComponent.builder()....build()로 객체 주입을 진행할 수 있다.
5. 사용을 원하는 클래스의 멤버에 @Inject 를 붙여서 주입받을 수 있다. 

## 참고 
- [Dependency Injection with Dagger 2](https://guides.codepath.com/android/Dependency-Injection-with-Dagger-2)
- [Dagger 2 Github Page](http://google.github.io/dagger/)
- [Sample project using Dagger 2](https://github.com/vinc3m1/nowdothis)
- [Vince Mi's Codepath Meetup Dagger 2 Slides](https://docs.google.com/presentation/d/1bkctcKjbLlpiI0Nj9v0QpCcNIiZBhVsJsJp1dgU5n98/)
- [http://code.tutsplus.com/tutorials/dependency-injection-with-dagger-2-on-android--cms-23345](http://code.tutsplus.com/tutorials/dependency-injection-with-dagger-2-on-android--cms-23345)
- [Jake Wharton's Devoxx Dagger 2 Slides](https://speakerdeck.com/jakewharton/dependency-injection-with-dagger-2-devoxx-2014)
- [Jake Wharton's Devoxx Dagger 2 Talk](https://www.parleys.com/tutorial/5471cdd1e4b065ebcfa1d557/)
- [Dagger 2 Google Developers Talk](https://www.youtube.com/watch?v=oK_XtfXPkqw)
- [Dagger 1 to Dagger 2](http://frogermcs.github.io/dagger-1-to-2-migration/)
- [Tasting Dagger 2 on Android](http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)
- [Dagger 2 Testing with Mockito](http://blog.sqisland.com/2015/04/dagger-2-espresso-2-mockito.html#sthash.IMzjLiVu.dpuf)
- [Snorkeling with Dagger 2<](https://github.com/konmik/konmik.github.io/wiki/Snorkeling-with-Dagger-2)
- [Dependency Injection in Java](https://www.objc.io/issues/11-android/dependency-injection-in-java/)
- [Component Dependency vs. Submodules in Dagger 2](http://jellybeanssir.blogspot.de/2015/05/component-dependency-vs-submodules-in.html)
- [Dagger 2 Component Scopes Test](https://github.com/joesteele/dagger2-component-scopes-test)